package com.monadpad.common;

import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.*;
import android.os.AsyncTask;
import android.preference.PreferenceManager;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewTreeObserver;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class MonadView extends View {

    private MonadJam mJam;
    private MonadJam mFadeJam;

    private boolean fresh = true;

    Paint pathPaint = new Paint();
    final Paint fingerPaint = new Paint();
    final Paint startDrawingPaint = new Paint();
    final Paint abcRectPaint = new Paint();
    final Paint fadePaint = new Paint();
    final Paint instrumentDescPaint = new Paint();

    final Paint fPaint;
    final Paint fP2;

    float x, y;
    boolean isTouching = false;
    float lastX;
    float lastY;
    float lastx;
    int instrument = 0;

    private int tutorial = 0;
    private int tutorial2Ups = 0 ;
    private boolean wasTutorial = false;
    private float tutorialWidth;

    private int nGrooveletSize = 0;
    private int nInstrumentWidth = 0;
    private ArrayList<String> grooveLets = new ArrayList<String>();
    boolean isTouchingGroovelet = false;
    private int lastGroovelet = -1;

    private boolean bending = false;
    private int bendPointer;
    private float bendStart;
    private float bendCount;

    boolean lAbc = false;
    private boolean lChangeInstrument = false;

    public final Paint[] colors;
    private final String[] colorDesc;
    private boolean showColorDesc = true;

    private int nShowingColumns = 0;
    private int nRowsPerColumn = 0;

    private boolean draggingUndo = false;

    //private boolean lockScreen;
    private boolean showBeats;
    private boolean showTime;

    private Path path;

    private Thread mRefreshThread;

    private IMonadViewListener mListener;

    private long fadeOutStarted = 0;
    private int fadeOutLength = 0;

    public final static int STATE_DRAW = 0;
    public final static int STATE_SELECT_FOR_LEVELS = 1;
    public final static int STATE_CHANGE_LEVELS = 2;
    private int state = STATE_DRAW;
    public final static int STATE_ANIMATE_CHANGE_LEVELS = 3;
    private float percentThruChange = 0.0f;


    private MonadChannel channelForLevels;
    private float panLevel = 0.5f;
    private float volumeLevel = 0.75f;
    private boolean movingPan = false;
    private boolean movingVolume = false;

    private int faderRadius = 30;
    private float volumeWidth;

    private boolean isSuperMonad = false;

    private boolean hasTakenTutorial = false;

    public MonadView(Context context, AttributeSet attrs) {
        super(context, attrs);

        isSuperMonad = context.getString(R.string.app_name).toUpperCase().contains("SUPER");

        colorDesc = getResources().getStringArray(R.array.instruments);
        colors = InstrumentFactory.getColors();

        setBackgroundColor(0xFF000000);

        pathPaint.setARGB(255, 255, 255, 255);
        pathPaint.setStyle(Paint.Style.STROKE);
        pathPaint.setStrokeWidth(4);
        pathPaint.setShadowLayer(6, 0, 0, 0xFFFFFFFF);

        fingerPaint.setARGB(128, 255, 255, 255);
        fingerPaint.setStyle(Paint.Style.FILL);
        fingerPaint.setShadowLayer(10, 0, 0, 0xFFFFFFFF);
        fingerPaint.setTextSize(20);

        instrumentDescPaint.setARGB(255, 0, 0, 0);
        instrumentDescPaint.setStyle(Paint.Style.FILL_AND_STROKE);
        instrumentDescPaint.setTextSize(20);

        abcRectPaint.setARGB(196, 128, 128, 128);
        abcRectPaint.setStyle(Paint.Style.FILL);

        startDrawingPaint.setARGB(255, 255, 255, 255);
        startDrawingPaint.setStyle(Paint.Style.FILL);
        startDrawingPaint.setTextSize(40);
        startDrawingPaint.setStrokeWidth(5);

        volumeWidth = startDrawingPaint.measureText("volume");
        tutorialWidth = startDrawingPaint.measureText("Tutorial");

        fPaint = new Paint();
        fP2 = new Paint();
        fPaint.setARGB(128, 255, 255, 255);
        fPaint.setStyle(Paint.Style.FILL);
        fPaint.setShadowLayer(10, 0, 0, 0xFFFFFFFF);
        fPaint.setTextSize(20);

        fP2.setARGB(64, 255, 255, 255);
        fP2.setStyle(Paint.Style.FILL);

        setKeepScreenOn(true);
        setFocusable(true);

        fadePaint.setARGB(196, 0, 0, 0);
        fadePaint.setStyle(Paint.Style.FILL);

    }

    boolean setJam(MonadJam jam){
        if (tutorial > 0  && tutorial != 3){
            tutorial = 0;
        }
        if (mFadeJam == null){
            fresh = true;
        }
        mJam = jam;
        mJam.changeNextInstrument(instrument);

        if (mJam.getChannels().size() > 0){
            getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
            public boolean onPreDraw() {

                try {
                    // if its got channels, we may need to make paths for them
                    for (MonadChannel c : mJam.getChannels()){
                        makePaths(c);
                    }
                } catch (Exception e){
                    Toast.makeText(getContext(), "Something went wrong making paths" +
                            "\n\nYou may need to update or upgrade", Toast.LENGTH_LONG).show();
                }
                getViewTreeObserver().removeOnPreDrawListener(this);
                return true;
                }
            });
            onModify();
        }

        return true;
    }
    public void resetClear(){
        tutorial2Ups = 0;

        if (tutorial == 2){
            tutorial++;
        }
        else if (tutorial > 0) {
            instrumentSettings(0);
            tutorial = 0;
        }

        draggingUndo = false;
        state = STATE_DRAW;
        fadeOutLength = 0;
        fadeOutStarted = 0;
        fresh = true;
        lastGroovelet = -1;
        lChangeInstrument = false;
        lAbc = false;
        if (mRefreshThread != null){
            mRefreshThread.interrupt();
            mRefreshThread = null;
        }

        invalidate();
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {

        if (state == STATE_CHANGE_LEVELS){
            changeLevels(event);
            return true;
        }

        float ex = event.getX();
        float ey = event.getY();

        x = ex / getWidth();
        y = 1 - ey / getHeight();

        // 2+ fingers down
        if (isBending(event))
            return true;

        if (event.getAction() == MotionEvent.ACTION_MOVE) {
            if (isTouching){
                mJam.addXY(x, y);
                path.lineTo(ex, ey);
                path.moveTo(ex, ey);
            }
        }

        if (event.getAction() == MotionEvent.ACTION_DOWN) {

            //check to see if this is a groovelet
            if (state == STATE_DRAW &&
                    !draggingUndo && !touchingGroovelet(event) && !touchingInstrument(event)){

                if (fresh && tutorialBoundary(ex, ey)){
                    startTutorial();
                }
                else{
                    onModify();
                    isTouching = true;
                    mJam.addXY(x, y);

                    if (!mJam.continuedChannel()){
                        path = new Path();
                        mJam.addPath(path, ex, ey);
                    }
                    path.moveTo(ex, ey);
                }
            }
        }

        if (event.getAction() == MotionEvent.ACTION_UP) {

            if (draggingUndo){
                undoDragFinal(ex, ey);
                draggingUndo = false;
            }

            if (state == STATE_SELECT_FOR_LEVELS){
                selectForLevels(ex, ey);
                return true;
            }

            if (isTouchingGroovelet){
                dropGroovelet(event);
                isTouchingGroovelet = false;

            }

            if (isTouching)
            {
                isTouching = false;
                mJam.addXY(x, y);
                mJam.addXY(x, -1);
                path.lineTo(ex, ey);
                path.moveTo(ex, ey);

                if (tutorial == 1) tutorial = 2;
                else if (tutorial == 3) {
                    tutorial = 4;
                    instrumentSettings(3);
                }
                else if (tutorial == 4){
                    tutorial2Ups++;
                    if (tutorial2Ups > 1){
                        tutorial = 5;
                        instrumentSettings(7);
                    }
                }
                else if (tutorial == 5) tutorial = 6;
                else if (tutorial == 8) tutorial = 9;
            }
        }
        lastx = x;
        lastX = ex;
        lastY = ey;

        invalidate();

/*        if (lockScreen){
            if (mainView.getHeight() > mainView.getWidth())
                mainView.getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
            else
                mainView.getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
        }
        */


        return true;
    }

    private boolean tutorialBoundary(float ex, float ey) {
        return ex > getWidth() - tutorialWidth * 2.0f
                && ey > getHeight() - startDrawingPaint.getTextSize() * 2;
    }

    @Override
    public void onDraw(Canvas canvas) {
        if (nGrooveletSize == 0){
            nGrooveletSize = 90;
            //nGrooveletSize = Math.round((float)mActivity.findViewById(R.id.abc).getWidth() * 1.5f);
        }

        if (tutorial > 0){
            DrawTutorial.drawTutorial(this, tutorial, canvas);
        }

        if (fadeOutLength > 0){

            float fadePerct = (float)(System.currentTimeMillis() - fadeOutStarted) / fadeOutLength;
            if (fadePerct > 1.0f){
                fadeOutStarted = 0;
                fadeOutLength = 0;
                mFadeJam = null;

                if (wasTutorial){
                    fresh = true;
                    wasTutorial = false;
                }
            }
            else {
                drawChannels(canvas, mFadeJam);

                fadePaint.setAlpha((int)(fadePerct * 255f));
                canvas.drawRect(0, 0, getWidth(), getHeight(), fadePaint);
            }
        }

        if (fresh && tutorial == 0) {
            float topOffset = getHeight() / 2 - startDrawingPaint.getTextSize();

            String startDrawing = "Start DRAWING!";
            float startDrawingLength = startDrawingPaint.measureText(startDrawing);
            canvas.drawText(startDrawing,
                    getWidth() / 2 - startDrawingLength / 2 , topOffset, startDrawingPaint);
            String firstDraw;
/*            if (!hasTakenTutorial){
                firstDraw = "Tip: Try the new Tutorial";
                canvas.drawText(firstDraw,
                        getWidth() / 2 - startDrawingLength / 2, topOffset + fingerPaint.getTextSize() * 2, fingerPaint);
                firstDraw = "Tip: Press MENU and explore";
                canvas.drawText(firstDraw,
                        getWidth() / 2 - startDrawingLength / 2, topOffset + fingerPaint.getTextSize() * 3
                        , fingerPaint);
            }
            else{
*/
                firstDraw = "Tip: The first draw sets the tempo";
                canvas.drawText(firstDraw,
                        getWidth() / 2 - startDrawingLength / 2, topOffset + fingerPaint.getTextSize() * 2, fingerPaint);
                firstDraw = "Tip: Draw from left to right";
                canvas.drawText(firstDraw,
                        getWidth() / 2 - startDrawingLength / 2, topOffset + fingerPaint.getTextSize() * 3
                        , fingerPaint);
//            }


            firstDraw = "Tutorial";
            canvas.drawRoundRect(new RectF(getWidth() - tutorialWidth * 2 ,
                    getHeight()- startDrawingPaint.getTextSize() * 2,
                    getWidth(), getHeight()), 10, 10, abcRectPaint);
            canvas.drawText(firstDraw,
                    getWidth() - tutorialWidth * 1.5f,
                    getHeight()- startDrawingPaint.getTextSize() / 2, startDrawingPaint);

        }

        if (state == STATE_ANIMATE_CHANGE_LEVELS){
            startDrawingPaint.setAlpha((int)(255.0f * percentThruChange));
            drawChangeLevels(canvas);
        }
        else if (state == STATE_CHANGE_LEVELS){
            drawChangeLevels(canvas);
        }
        else {
            drawChannels(canvas, mJam);
        }

        nShowingColumns = 0;
        if (lChangeInstrument){
            drawInstruments(canvas);
        }
        else if (lAbc ){
            drawABC(canvas);
        }

        if (isTouching) {
            canvas.drawCircle(lastX, lastY, 15, fingerPaint);
        }
    }


    public void instrumentSettings(int pos){
        instrument = pos;
        int a = colors[pos].getAlpha();
        colors[pos].setAlpha(255);
        if (mListener != null)
            mListener.newColor(colors[pos].getColor(), pos);

        colors[pos].setAlpha(a);
        mJam.changeNextInstrument(instrument);
    }

    private boolean touchingGroovelet(MotionEvent e){

        if (!lAbc)
            return false;

        float y = e.getY();
        float x = e.getX();
        int ig = getGrooveletSquare(x, y);

        if (ig == -1){
            return false;
        }
        else if (ig == 0){
            grooveLets.add(mJam.getGrooveInfo());
            lastGroovelet = grooveLets.size() - 1;

            if (tutorial == 7) {
                tutorial = 8;
                instrumentSettings(2);
            }
            else if (tutorial == 9) tutorial = 10;

            return true;
        }
        else if (ig == 1){
            grooveLets.clear();
            return true;
        }
        else {
            ig = ig - 2;
            if (lastGroovelet == ig){
                mJam.setLoopBack();
            } else {
                if (tutorial == 10) tutorial = 11;

                mJam.finishAllChannels();

                int firstInst = instrument;
                String[] sLines = grooveLets.get(ig).split(":");
                String[] line1 = sLines[0].split(";");

                //adjust the bounds of the loops if necessary
                if (line1.length > 1){
                    float lineStart = Float.valueOf(line1[1]) ;
                    float lineLength = Float.valueOf(line1[2]) ;
                    mJam.adjustBounds(lineStart, lineLength);
                }

                for (int ils=1; ils<sLines.length; ils++ ){

                    MonadChannel mpc = mJam.loadChannel(sLines[ils]);
                    makePaths(mpc);

                    //16 not 17 because no "good;"
                    if (line1.length > 16 + 1 + (ils - 1) * 2){
                        float gain = Float.parseFloat(line1[16 + (ils - 1) * 2]);
                        float pan = Float.parseFloat(line1[16 + 1 + (ils - 1) * 2]);
                        mpc.setGain(gain);
                        mpc.pan(pan);

                    }
                }
                instrumentSettings(firstInst);
                onModify();
                lastGroovelet = ig;
            }

            isTouchingGroovelet = true;
            return true;
        }
    }

    private boolean touchingInstrument(MotionEvent e){

        if (!lChangeInstrument)
            return false;

        lChangeInstrument = false;
        float y = e.getY();
        float x = e.getX();
        int nStart, nStop;

        for (int ic = 0; ic < nShowingColumns + 1; ic++){
            if (x < nInstrumentWidth * (ic + 1)){

                if (nRowsPerColumn == 0){
                    nStart = 0;
                    nStop = colors.length;
                }
                else {
                    nStart = ic * nRowsPerColumn;
                    nStop = Math.min(nRowsPerColumn, colors.length -  ic  * nRowsPerColumn);
                }
                for (int ig= 0 ; ig < nStop; ig++){
                    if (y <= nGrooveletSize * (ig + 1)){

                        instrumentSettings(ig + nStart);

                        return true;
                    }
                }
                break;
            }
        }

        return true;
    }


    private boolean dropGroovelet(MotionEvent e){
        int ig = getGrooveletSquare(e.getX(),  e.getY());

        if (ig < 2){
            return false;
        }
        else {
            ig = ig - 2;

            if (!(ig == lastGroovelet)){
                int firstInst = instrument;
                String[] sLines = grooveLets.get(ig).split(":");
                for (int ils=1; ils<sLines.length; ils++ ){
                    makePaths(mJam.loadChannel(sLines[ils]));
                }
                instrumentSettings(firstInst);
                lastGroovelet = -1;
            }
            return true;
        }
    }

    public boolean undo(){
        onModify();
        if (draggingUndo){
            draggingUndo = false;
//            mThread.undoDragCancel();
            invalidate();
        }
        else if (mJam.isSetup()){
            mJam.undo();
            invalidate();
        }
        else return false;
        return true;
    }
    public void undoDrag(){
        if (mJam.isSetup()){
            if (draggingUndo){
                draggingUndo = false;
                invalidate();
            }
            else{
                lChangeInstrument = false;
                lAbc = false;
                draggingUndo = true;
                if (mJam.isSetup()){
                    invalidate();
                }
            }
        }
    }

    public void fadeOut(){
        lAbc = false;
        lChangeInstrument = false;
        mFadeJam = mJam;
        fadeOutStarted = System.currentTimeMillis();
        fadeOutLength = MonadJam.FADE_OUT_LENGTH;

        if (tutorial == 12){
            tutorial = 0;
            wasTutorial = true;
            instrumentSettings(0);
        }

        if (mRefreshThread == null)
            makeRefreshThread();
    }

    public boolean abc(){
        draggingUndo = false;
        state = STATE_DRAW;
        if (lChangeInstrument){
            lChangeInstrument = false;
            lAbc = true;
        }
        else {
            lAbc = !lAbc;
        }
        invalidate();
        return lAbc;
    }

    public void changeInstrument(){
        nInstrumentWidth = nGrooveletSize * (showColorDesc ? 2 : 1);
        state = STATE_DRAW;
        draggingUndo = false;
        if (lAbc){
            lAbc = false;
            lChangeInstrument = true;
        }
        else {
            lChangeInstrument = ! lChangeInstrument;
        }
        invalidate();
    }

    public String[] getGroovelets(){
        String[] ret = new String[grooveLets.size()];
        for (int ig = 0; ig< ret.length;ig++){
            ret[ig] = grooveLets.get(ig);
        }
        return ret;
    }

    public void setGroovelets(String[] gs){
        grooveLets.clear();
        grooveLets.addAll(Arrays.asList(gs));
    }

    private int getGrooveletSquare(float x, float y){
        int ret = -1;
        for (int ic = 0; ic <nShowingColumns + 1; ic++){
            if (x < nGrooveletSize * (ic + 1)){
                int nStop = nRowsPerColumn == 0 ? grooveLets.size() + 2 :
                        Math.min(nRowsPerColumn, grooveLets.size() + 2 - ic * nRowsPerColumn);
                for (int ir = 0; ir < nStop; ir++){
                    if (y < nGrooveletSize * (ir + 1)){

                        ret = ir + nRowsPerColumn * ic;
                        return  ret;
                    }
                }
            }
        }
        return ret;
    }

    public void onModify(){
        if (fresh){
            fresh = false;
            if (showTime){
                makeRefreshThread();
            }
            else{
                invalidate();
            }
        }
        lastGroovelet = -1;
        if (mJam.getSourceInfo().source == MonadJamSourceInfo.GALLERY_SOURCE_GALLERY){
            mJam.getSourceInfo().source = MonadJamSourceInfo.GALLERY_SOURCE_MODIFIED_GALLERY;
            mJam.getSourceInfo().id = 0;
        }
        else if (mJam.getSourceInfo().source == MonadJamSourceInfo.GALLERY_SOURCE_SD){
            mJam.getSourceInfo().source = MonadJamSourceInfo.GALLERY_SOURCE_USER;
        }
    }

    private void makeRefreshThread() {
        mRefreshThread = new Thread(new Runnable() {
            public void run() {
                while (true){
                    postInvalidate();
                    try{
                        Thread.sleep(50);
                    } catch (InterruptedException e) {break;}
                }
            }
        });
        mRefreshThread.start();
    }

    private boolean isBending(MotionEvent event){

        if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_DOWN) {
            if (!bending){

                if (isTouching){
                    mJam.cancelCurrentChannel();
                    isTouching = false;
                }

                bendCount = 0;
                bending = true;
                bendPointer = event.getPointerId(0);
                bendStart = event.getY(0);
            }
            if (tutorial == 6) {
                tutorial = 7;
                grooveLets.clear();
            }
            return true;

        }
        if (event.getPointerCount() > 1){
            if (event.getAction() == MotionEvent.ACTION_MOVE) {

                try {
                    float bendY = event.getY(event.findPointerIndex(bendPointer));
                    float bendDiff = bendStart - bendY;

                    mJam.bend(bendDiff , bendDiff / getHeight());
                    bendCount = bendCount + bendDiff;
                    bendStart = bendY;

                }
                catch (Exception e){
                    bending = false;
                }
            }

            invalidate();
            return true;
        }
        else if (bending){
            bending = false;
            mJam.bend((-1 * bendCount) , (-1 * bendCount) / getHeight());
            invalidate();
        }
        return false;

    }

    public void drawChannels(Canvas canvas, MonadJam jam) {
        if (jam == null)
            return;
        Paint p;

        int circleRadius = draggingUndo || state == STATE_SELECT_FOR_LEVELS ? 20 : 8;

        List<MonadChannel> chans = jam.getChannels();
        MonadChannelViewInfo info;
        for (MonadChannel channel : chans){
            info = channel.getViewInfo();
            p = colors[info.instrument];

            canvas.drawPath(info.path, p);

            canvas.drawCircle(info.originX, info.originY, circleRadius, p);
        }
        MonadChannel channel = jam.getLiveChannel();
        if (channel != null){
            p = colors[channel.getViewInfo().instrument];
            canvas.drawPath(channel.getViewInfo().path, p);
        }

        if (jam.isSetup()){

            float x, lineLength, lineStart;
            lineStart = jam.getLineStart() * getWidth();
            lineLength = jam.getLineLength() * getWidth();
            if (showBeats){
                x= lineStart;
                canvas.drawLine(x, 0, x, getHeight(), fPaint);
                x = lineStart + lineLength * 0.25f;
                canvas.drawLine(x, 0, x, getHeight(), fP2);
                x = lineStart + lineLength * 0.5f;
                canvas.drawLine(x, 0, x, getHeight(), fP2);
                x = lineStart + lineLength * 0.75f;
                canvas.drawLine(x, 0, x, getHeight(), fP2);
                x = lineLength + lineStart;
                canvas.drawLine(x, 0, x, getHeight(), fPaint);
            }
            if (showTime){
                x = lineStart + lineLength * jam.getNowInLoop();
                canvas.drawLine(x, 0, x, canvas.getHeight(), fPaint);
            }
        }
    }

    public void setPreferences(){
        final SharedPreferences synthPrefs = PreferenceManager
                .getDefaultSharedPreferences(getContext());

//        lockScreen = synthPrefs.getBoolean("lockscreen", false);
        showBeats = synthPrefs.getBoolean("showbeats", true);
        showTime = synthPrefs.getBoolean("showtime", true);
        showColorDesc = synthPrefs.getBoolean("showColorDesc", true);

        if (showTime && mJam.isSetup() && mRefreshThread == null){
            makeRefreshThread();
        }
    }

    public void makePaths(MonadChannel c){
        float x, y;
        float[] xys;
        float lastY;

        // if its got channels, we may need to make paths for them
        path = new Path();
        lastY = -1;

        xys = c.getXYs();

        for (int ic = 0; ic < xys.length; ic++){

            x = xys[ic];
            y = xys[ic + 1];

            if (ic == 0){
                c.getViewInfo().originX =  x * getWidth();
                c.getViewInfo().originY = (1 - y) * getHeight();
            }

            if (y > -1 ){
                if (lastY > -1){
                    path.lineTo(x * getWidth(), (1 - y) * getHeight());
                }
                path.moveTo(x * getWidth(), (1 - y) * getHeight());
            }

            //go up by 2
            ic++;
            lastY = y;
        }
        c.getViewInfo().path = path;

    }

    private void drawInstruments(Canvas canvas){
        Rect r = new Rect() ;
        String desc = "";
        int iRow = 0;
        int instrumentCount = colors.length;
        if (!isSuperMonad) instrumentCount = instrumentCount - 2;

        for (int ig = 0; ig< instrumentCount; ig++) {
            colors[ig].setAlpha(255);
            if (iRow * nGrooveletSize + nGrooveletSize > getHeight()) {
                nShowingColumns++;
                nRowsPerColumn = iRow;
                iRow = 0;
            }
            r.set(nShowingColumns * nInstrumentWidth, nGrooveletSize * iRow,
                    nShowingColumns * nInstrumentWidth + nInstrumentWidth, nGrooveletSize + nGrooveletSize * iRow);

            canvas.drawRect(r, colors[ig]);
            if (showColorDesc) {
                if (ig < colorDesc.length)
                    desc = colorDesc[ig];
                canvas.drawText(desc,
                        nShowingColumns * nInstrumentWidth + nGrooveletSize / 5,
                        nGrooveletSize * iRow + nGrooveletSize / 2, instrumentDescPaint);
            }
            iRow++;
        }

    }

    private void drawABC(Canvas canvas){
        // draw the groovelets
        Rect r = new Rect(0, 0, nGrooveletSize, nGrooveletSize);
        canvas.drawRect(r, abcRectPaint);
        String firstBox = "Add +";
        canvas.drawText(firstBox,
                nGrooveletSize/8, nGrooveletSize/2, fingerPaint);

        if (grooveLets.size() > 0){

            r = new Rect(0, nGrooveletSize, nGrooveletSize,
                    nGrooveletSize * 2) ;

            canvas.drawRect(r, abcRectPaint);
            canvas.drawText("Clear",
                    nGrooveletSize/8,
                    nGrooveletSize + nGrooveletSize/2,
                    fingerPaint);

            int iRow = 2;

            for (int ig = 0; ig < grooveLets.size(); ig++){
                if (iRow * nGrooveletSize + nGrooveletSize > getHeight()){
                    nShowingColumns++;
                    nRowsPerColumn = iRow;
                    iRow = 0;
                }

                r.set(nGrooveletSize * nShowingColumns, nGrooveletSize * iRow ,
                        nGrooveletSize * (nShowingColumns + 1), nGrooveletSize * (iRow + 1));
                if (lastGroovelet == ig){
                    canvas.drawRect(r, fingerPaint);
                    canvas.drawText(Character.toString((char)(ig + 65)),
                            nGrooveletSize * nShowingColumns  + nGrooveletSize/3,
                            nGrooveletSize * iRow  + nGrooveletSize/2, instrumentDescPaint);

                } else {
                    canvas.drawRect(r, abcRectPaint);
                    canvas.drawText(Character.toString((char)(ig + 65)),
                            nGrooveletSize *nShowingColumns + nGrooveletSize/3,
                            nGrooveletSize * iRow + nGrooveletSize/2, fingerPaint);
                }
                iRow++;
            }
        }

        if (isTouchingGroovelet) {
            r.set((int)lastX - nGrooveletSize, (int)lastY - nGrooveletSize/2,
                    (int)lastX + nGrooveletSize, (int)lastY + nGrooveletSize/2);
            canvas.drawRect(r, fingerPaint);
        }
    }

    public void startTutorial() {
        setBackgroundDrawable(null);
        mJam.setSettingsToDefault();
        instrumentSettings(1);

        resetClear();
        tutorial = 1;
        invalidate();
        hasTakenTutorial = true;
    }

    public void maybeUpdateTutorial() {
        if (tutorial == 6 ){
            tutorial = 7;
            invalidate();
        }
    }

    public void levels() {
        if (mJam.isSetup()){
            draggingUndo = false;
            lAbc = false;
            lChangeInstrument = false;
            if (state != STATE_DRAW)
                state = STATE_DRAW;
            else{
                state = STATE_SELECT_FOR_LEVELS;
            }
            invalidate();
        }
    }

    interface IMonadViewListener{
        public void newColor(int p , int pos);
        public void changingState(int newState);
    }

    public void setListener(IMonadViewListener listener){
        mListener = listener;
    }

    private void undoDragFinal(float x, float y){

        for (MonadChannel mpc : mJam.getChannels()){
            if (mpc.hitTest(x, y)){
                if (tutorial == 11 ) tutorial++;
                mJam.undoChannel(mpc);
                onModify();
                break;
            }
        }
    }
    private void selectForLevels(float x, float y){


        boolean gotOne = false;

        for (MonadChannel mpc2 : mJam.getChannels()){
            if (mpc2.hitTest(x, y)){
                gotOne = true;
                channelForLevels = mpc2;
                break;
            }
        }
        if (gotOne){
            // let's animate the appearance of the levels
            new AnimateLevels().execute();
            panLevel = 0.5f + channelForLevels.getPan() / (2f / 0.66f);
            volumeLevel = 0.25f + ((1 - channelForLevels.getGain()) / 2);

            if (mListener != null)
                mListener.changingState(STATE_CHANGE_LEVELS);

        }
        else {
            state = STATE_DRAW;
        }
    }

    private void drawChangeLevels(Canvas canvas){
        MonadChannelViewInfo info = channelForLevels.getViewInfo();
        Paint pathPaint = colors[info.instrument];
        int alpha = pathPaint.getAlpha();
        pathPaint.setAlpha(64);
        canvas.drawPath(info.path, pathPaint);
        pathPaint.setAlpha(alpha);

        canvas.drawText("volume",
                0, getHeight() * 0.25f - startDrawingPaint.getTextSize(), startDrawingPaint);
        canvas.drawLine(volumeWidth / 2, getHeight() * 0.25f, volumeWidth / 2, getHeight() * 0.75f,
                startDrawingPaint);

        String panString = isSuperMonad ? "<left - PAN - right>" : "get Super Draw Music to PAN";
        Paint panPaint = isSuperMonad ? startDrawingPaint : fingerPaint;
        canvas.drawText(panString,
                getWidth() * 0.5f - panPaint.measureText(panString) / 2,
                getHeight() * 0.80f + (float)faderRadius + startDrawingPaint.getTextSize(), panPaint);

        canvas.drawLine(getWidth() * 0.166f, getHeight() * 0.80f, getWidth() * 0.833f, getHeight() * 0.80f,
                startDrawingPaint);

        canvas.drawCircle(volumeWidth/2, volumeLevel * getHeight(), faderRadius, colors[1]);
        canvas.drawCircle(getWidth() * panLevel, getHeight() * 0.80f, faderRadius, colors[1]);

    }

    private void changeLevels(MotionEvent event){
        float ex = event.getX();
        float ey = event.getY();

        x = ex / getWidth();
        y = 1 - ey / getHeight();

        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            if (isSuperMonad && Math.abs(ey - getHeight() * 0.8) < faderRadius){
                movingPan = true;
            }
            else if (ey < getHeight() * 0.8 && Math.abs(ex - volumeWidth / 2) < faderRadius){
                movingVolume = true;
            }

        }
        if (event.getAction() == MotionEvent.ACTION_MOVE) {
            if (movingPan){
                panLevel = Math.max(0.166f, Math.min(ex / getWidth(), 0.833f));
                float panLevel2 = (panLevel - 0.5f) * (2f / 0.66f);
                channelForLevels.pan( panLevel2 );
                invalidate();
            }
            if (movingVolume){
                volumeLevel = Math.max(0.25f, Math.min(ey / getHeight(), 0.75f));

                float volumeLevel2 = 1 - ((volumeLevel - 0.25f) * 2f);
                channelForLevels.setGain( volumeLevel2 );
                invalidate();
            }
        }
        if (event.getAction() == MotionEvent.ACTION_UP){
            movingPan = false;
            movingVolume = false;
        }
    }

    class AnimateLevels extends AsyncTask<Void, Void, Void> {

        @Override
        protected Void doInBackground(Void... objects) {
            percentThruChange = 0.0f;
            state = STATE_ANIMATE_CHANGE_LEVELS;
            long now = System.currentTimeMillis();
            long startTime = now;
            while (now < startTime + 1000){

                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                percentThruChange = (float)(now - startTime) / 1000.0f;
                postInvalidate();
                now = System.currentTimeMillis();

            }
            if (state == STATE_ANIMATE_CHANGE_LEVELS){
                state = STATE_CHANGE_LEVELS;
            }
            return null;
        }
    }
}
