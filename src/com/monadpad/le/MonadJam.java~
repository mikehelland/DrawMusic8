package com.monadpad.common;

import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.graphics.Path;
import android.preference.Preference;
import android.preference.PreferenceManager;
import android.provider.CallLog;
import android.util.Log;
import android.view.Display;
import android.widget.Toast;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.Console;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class MonadJam {
    private MonadThread mThread;

    public static int FADE_OUT_LENGTH = 5000;

    private long lastUp = 0;
    private long loopLengthCounter = 0;
    private long loopDuration = 0;

    private boolean loopIsSetup = false;
    private boolean threadRunning = false;

    private MonadChannel currentChannel = null;
    private MonadChannel lastChannel = null;

    private String scale;
    private int octaves;
    private int autoremove;
    private int base;

    private boolean currentChannelIsLive = false;

    private float lineStart = 0;
    private float lineLength = 0;

    private List<MonadChannel> channels = new CopyOnWriteArrayList<MonadChannel>();
    private List<MonadChannel> qChannels = new ArrayList<MonadChannel>();

    //boolean mGalleryState = true;

    private int nextInstrument = 0;

    private boolean cleanFromUndo = false;

    private boolean continuedLastChannel = false;

    private MonadJamSourceInfo mSourceInfo = new MonadJamSourceInfo();

    private Context context;

    private boolean lockScreen;
    private boolean isScreenLocked = false;

    public MonadJam(Context ctx){
        setup(ctx);
        useDefaultSettings();
        currentChannel = newChannel();
    }

    void setSettingsToDefault(){

        SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(context);
        SharedPreferences.Editor edit = settings.edit();
        edit.putString("quantizer", "0,2,4,5,7,9,11");
        edit.putString("octaves", "4");
        edit.putString("base", "36");
        edit.putString("autoremove", "4");
        edit.commit();
        scale = "0,2,4,5,7,9,11";
        octaves = 4;
        base = 36;
        autoremove = 4;

        currentChannel = newChannel();
    }


    private void useDefaultSettings() {
        final SharedPreferences synthPrefs = PreferenceManager
                .getDefaultSharedPreferences(context);
        scale = synthPrefs.getString("quantizer", "0,2,4,5,7,9,11");
        octaves = Integer.parseInt(synthPrefs.getString("octaves", "4"));
        String ar = synthPrefs.getString("autoremove", "4");
        if (ar.equalsIgnoreCase("OFF") || ar.startsWith("0"))
            autoremove = 0;
        else
            autoremove = Integer.parseInt(ar);
        base = Integer.parseInt(synthPrefs.getString("base", "36"));

    }

    public MonadJam(Context ctx, String info){
        setup(ctx);
        setupFromString(info, false);
    }

    public MonadJam(Context ctx, String info, boolean useDefaults){
        setup(ctx);
        setupFromString(info, useDefaults);
    }

    private void setup(Context ctx){
        context = ctx;

        mThread = new MonadThread(this);
        currentChannel = newChannel();

        final SharedPreferences synthPrefs = PreferenceManager
                .getDefaultSharedPreferences(context);
        lockScreen = synthPrefs.getBoolean("lockscreen", false);

    }

    private void setupFromString(String info, boolean useDefaults){
        if (info.startsWith("{")){
            try {

                JSONObject jsO = new JSONObject(info);

                loopDuration = jsO.getInt("duration");
                lineStart = (float)jsO.getDouble("startLine");
                lineLength = (float)jsO.getDouble("lineLength");
                if (!useDefaults){
                    //JSONArray jsScale = jsO.getJSONArray("sca")
                    scale = jsO.getString("ascale").replace("[","").replace("]","");
                    octaves = jsO.getInt("octaves");
                    base= jsO.getInt("base");
                    //autoremove = Integer.valueOf(line1[7]);
                    SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(context);
                    SharedPreferences.Editor edit = settings.edit();
                    edit.putString("quantizer", scale);
                    edit.putString("octaves", Integer.toString(octaves));
                    edit.putString("base", Integer.toString(base));
                    //edit.putString("autoremove", line1[7]);
                    edit.commit();
                }
                else {
                    useDefaultSettings();
                }
                //the next lines should have X and Y coords
                JSONArray jsChans = jsO.getJSONArray("channels");
                for (int ils=0; ils<jsChans.length(); ils++ ){

                    MonadChannel mpc = newChannel(jsChans.getJSONObject(ils));

//                        float gain = Float.parseFloat(line1[17 + (ils - 1) * 2]);
//                        float pan = Float.parseFloat(line1[17 + 1 + (ils - 1) * 2]);
//                        mpc.setGain(gain);
//                        mpc.pan(pan);

                    if (mpc != null) {
                        mpc.popCherry();
                        mpc.prepareLoop(loopDuration, lineStart, lineLength);
                    }
                    channels.add(mpc);
                }

                if (channels.size() > 0){
                    loopIsSetup = true;
                    mThread.setupLoop(loopDuration);
                    mThread.startLoop();
                    mThread.start();
                    if (lockScreen) lockTheScreen();
                    threadRunning = true;
                    //            fresh = false;
                }
            }
            catch (JSONException e) {
                String msg = "Failed to load data\n\nYou may need to update or upgrade";
                if (e.getMessage() != null)
                    msg = msg + "\n\n" + e.getMessage();
                Toast.makeText(context, msg, Toast.LENGTH_LONG).show();
                e.printStackTrace();
            }
        }
        else{
            try{

                String[] sLines = info.split(":");

                //the first line should have the duration, linestart, and linelength
                String[] line1 = sLines[0].split(";");

                loopDuration = Long.valueOf(line1[1]);
                lineStart = Float.valueOf(line1[2]);
                lineLength = Float.valueOf(line1[3]);

                if (!useDefaults){
                    scale = line1[4];
                    octaves = Integer.valueOf(line1[5]);
                    base= Integer.valueOf(line1[6]);
                    autoremove = Integer.valueOf(line1[7]);
                    SharedPreferences settings = PreferenceManager.getDefaultSharedPreferences(context);
                    SharedPreferences.Editor edit = settings.edit();
                    edit.putString("quantizer", line1[4]);
                    edit.putString("octaves", line1[5]);
                    edit.putString("base", line1[6]);
                    edit.putString("autoremove", line1[7]);
                    edit.commit();
                }
                else {
                    useDefaultSettings();
                }

                //the next lines should have X and Y coords
                for (int ils=1; ils<sLines.length; ils++ ){

                    MonadChannel mpc = newChannel(sLines[ils]);

                    if (line1.length > 17 + 1 + (ils - 1) * 2){
                        float gain = Float.parseFloat(line1[17 + (ils - 1) * 2]);
                        float pan = Float.parseFloat(line1[17 + 1 + (ils - 1) * 2]);
                        mpc.setGain(gain);
                        mpc.pan(pan);
                    }

                    if (mpc != null) {
                        mpc.popCherry();
                        mpc.prepareLoop(loopDuration, lineStart, lineLength);
                    }
                    channels.add(mpc);
                }

                if (channels.size() > 0){
                    loopIsSetup = true;
                    mThread.setupLoop(loopDuration);
                    mThread.startLoop();
                    mThread.start();
                    if (lockScreen) lockTheScreen();
                    threadRunning = true;
                    //            fresh = false;
                }

            }
            catch (Exception e) {
                String msg = "Failed to load data\n\nYou may need to update or upgrade";
                if (e.getMessage() != null)
                    msg = msg + "\n\n" + e.getMessage();
                Toast.makeText(context, msg, Toast.LENGTH_LONG).show();
                e.printStackTrace();
            }

        }
    }


    public void stop(){
        mThread.interrupt();
    }
    public void niceStop(){
        stop(3000);
    }
    public void stop(int stopTime){
        if (mThread.isAlive()){
            mThread.reset(stopTime);

            if (isScreenLocked){
                ((Activity)context).setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
                isScreenLocked = false;
            }
        }
    }

    public boolean isSetup(){
        return loopIsSetup;
    }

    public void addXY(float x, float y){
        addXYTP(x, y, -1, -2);

    }
    public void addXYTP(float x, float y, long time, float pan){

        if (!threadRunning) {
            mThread.start();
            threadRunning = true;
            lockTheScreen();
        }

        continuedLastChannel = false;

        MonadChannel chan = currentChannel;
        if (y > -1){
            long nBreakThreshold = 700;
            if (lastUp > 0 && System.currentTimeMillis() - lastUp < nBreakThreshold && lastChannel != null) {

                continuedLastChannel = true;
                currentChannel = lastChannel;
                chan = currentChannel;

                currentChannel.unloop();

                // if this is the first track, make sure to keep counting
                if (channels.size() == 1 && !cleanFromUndo)
                    loopIsSetup = false;

            } else {
                if (x == -1f || currentChannelIsLive ||
                        (currentChannel.free && loopIsSetup && x > getBoundary())){
                    currentChannelIsLive = true;
                    currentChannel.unmute();
                    x = -1f;
                } else{
    //                onModify();
                    if (!loopIsSetup && loopLengthCounter == 0){
                        loopLengthCounter = System.currentTimeMillis();
                    }

                    currentChannelIsLive = false;

                    if (currentChannel.free){
                        channels.add(currentChannel);

                        if (autoremove > 0 && channels.size() > autoremove){
                            doAutoRemove();
                        }

                        currentChannel.free = false;
                    }
                }
            }
            chan.addXY(time, pan, x, y);
        }
        else {
            if (currentChannelIsLive){
                lastUp = 0;
                currentChannelIsLive = false;
                currentChannel.getViewInfo().path = null;
                qChannels.add(currentChannel);
                currentChannel.slowFinish();
                currentChannel = newChannel();
            }
            else {
                lastUp = System.currentTimeMillis();
                chan.addXY(time, pan, x, y);
                lastChannel = currentChannel;
                currentChannel = newChannel();

                boolean okToStart = false;
                if (!loopIsSetup){
                    loopDuration = System.currentTimeMillis() - loopLengthCounter;
                    okToStart = mThread.setupLoop(loopDuration);
                    lineStart =  chan.getLow();
                    lineLength = chan.getHigh() - lineStart;

                    currentChannel.popCherry();
                }

                chan.prepareLoop(loopDuration, lineStart, lineLength);

                if (!loopIsSetup && okToStart){
                    mThread.startLoop();
                    loopIsSetup = true;
                }
            }
        }
    }

    public float getBoundary(){
        return lineStart + lineLength;
    }

/*


    public void finishAllChannelsHard(){
        while( channels.size() > 0){
            channels.get(0).finish();
            channels.remove(0);
        }

    }


    public int getChannelCount(){
        return channels.size();
    }
*/

    public void setLoopBack(){
        mThread.setLoopBack();
    }


    public String getGrooveInfo(){
        //duration,linestart,linelength
        if (!loopIsSetup)
            return "";

        StringBuilder info = new StringBuilder();
        info.append(loopDuration);
        info.append(";");
        info.append(lineStart);
        info.append(";");
        info.append(lineLength);
        info.append(";");
        info.append(scale);
        info.append(";");
        info.append(octaves);
        info.append(";");
        info.append(base);
        info.append(";");
        info.append(autoremove);
        info.append( ";" + "ANY;;;;;;;;");
        for (MonadChannel channel : channels) {
            info.append(";");
            info.append(channel.getGain());
            info.append(";");
            info.append(channel.getPan());
        }

        for (MonadChannel channel : channels) {
            info.append(":");
            info.append(channel.getChannelInfo());
        }
        return info.toString();
    }

    public void bend(float amt, float amtP){
        for (MonadChannel mc : channels){
            mc.bend(amt, amtP);
        }
    }
    /*



    public long getDuration(long duration) {

        return duration;
        /*
        long ret = 0;

        if (duration > 0){
            float bpm = 240000f / (float)duration;
            int bmp2 = Math.round(bpm);
            ret = (long)(240000f / bmp2);

            Log.d("MGH", Float.toString(ret));
            //    ret = duration;
            Log.d("MGH", Float.toString(duration));
            Log.d("MGH", Float.toString(240000f / ret));
            Log.d("MGH", Integer.toString(bmp2));
        }
        return ret;

    }
        */


    MonadChannel newChannel(){
        return new MonadChannel(nextInstrument, scale, octaves, base);
    }

    MonadChannel newChannel(String channelData){

        MonadChannel chan = null;

        if (!channelData.contentEquals("0")){

            String[] sCoords = channelData.split(";");

            if (sCoords.length > 1){

                chan = new MonadChannel(Integer.valueOf(sCoords[0]), scale, octaves, base);
                chan.mute();

                float ojX;
                float ojY;
                for (int iss=1; iss<sCoords.length - 1; iss =iss+ 2 ){

                    ojX = Float.valueOf(sCoords[iss]);
                    ojY = Float.valueOf(sCoords[iss+1]);
                    chan.addXY(-1, -2, ojX, ojY);
                }
            }
        }
        return chan;
    }

    MonadChannel newChannel(JSONObject channelData) throws JSONException {

        MonadChannel chan = null;
        JSONArray jsA = channelData.getJSONArray("data");

        chan = new MonadChannel(channelData.getInt("instrument"), scale, octaves, base);
        chan.mute();

        float ojX;
        float ojY;
        for (int iss=0; iss<jsA.length(); iss++ ){

            ojX = (float)jsA.getJSONArray(iss).getDouble(0);
            ojY = (float)jsA.getJSONArray(iss).getDouble(1);
            if (ojY > -1){
                ojY = 1 - ojY;
            }
            chan.addXY(-1, -2, ojX, ojY);
        }
        return chan;
    }


    List<MonadChannel> getChannels(){
        return channels;
    }
    List<MonadChannel> getQChannels(){
        return qChannels;
    }

    public float getLineStart(){
        return lineStart;
    }

    public float getLineLength(){
        return lineLength;
    }

    void addPath(Path p, float originX, float originY){
        if (currentChannel != null){
            currentChannel.getViewInfo().path = p;
            currentChannel.getViewInfo().originX = originX;
            currentChannel.getViewInfo().originY = originY;
        }
    }
    void addTouchList(MonadPad3DView.TouchList tl){
        if (currentChannel != null){
            currentChannel.getViewInfo().setTouchList( tl );
        }
    }

    void changeNextInstrument(int nextInstrument){
        this.nextInstrument = nextInstrument;
        currentChannel = newChannel();
    }

    MonadChannel getLiveChannel(){
        if (currentChannelIsLive){
            return currentChannel;
        }
        else
            return null;
    }

    public void undo(){
        if (channels.size() > 0){
            MonadChannel chan = channels.get(channels.size() - 1);
            undoChannel(chan);
            lastUp = 0;
        }
    }

    void undoChannel(MonadChannel chan){
        chan.finish();
        channels.remove(chan);
        qChannels.add(chan);

        if (channels.size() == 0){
            cleanFromUndo = true;
        }
    }

    void doAutoRemove(){
        //TODO glithcy performance here? maybe to do with fade calculations? maybe not
        undoChannel(channels.get(0));
    }

    public void refreshPreference(Preference preference, Object o) {

        String key = preference.getKey();
        if (key.equals("autoremove")){
            String ar = o.toString();
            if (ar.equalsIgnoreCase("OFF"))
                autoremove = 0;
            else
                autoremove = Integer.parseInt(ar);
        }
        else {
            if (key.equals("quantizer")){
                scale = o.toString();
            }
            else if (key.equals("octaves")){
                octaves = Integer.parseInt(o.toString());
            }
            else if (key.equals("base")){
                base = Integer.parseInt(o.toString());
            }

            // the  basic settings of the music have changed
            // RECALCULATING!!!
            for (MonadChannel mpc : channels){
                mpc.rebuildFrequencies(scale, octaves, base);
            }
        }

    }

    public MonadChannel loadChannel(String sLine) {
        MonadChannel mpc = newChannel(sLine);
        channels.add(mpc);
        mpc.prepareLoop(loopDuration, lineStart, lineLength);
        return mpc;
    }

    public void finishAllChannels(){
        while( channels.size() > 0){
            channels.get(0).finish();
            qChannels.add(channels.get(0));
            channels.remove(0);
        }
        cleanFromUndo = true;
    }

    public void adjustBounds(float lineStart, float lineLength){
        this.lineStart = lineStart;
        this.lineLength = lineLength;
    }

    public float getNowInLoop() {
        if (isSetup())
            return (float)(System.currentTimeMillis() - mThread.getLoopCounter()) / (float)loopDuration;
        else
            return 0;
    }

    public float getBPM(){
        float ret = 0f;

        if (isSetup()){
            ret = 240000f / ((float)loopDuration);
        }
        return ret;
    }

    public void fadeOut() {
        for (MonadChannel channel : channels)
            channel.fade(FADE_OUT_LENGTH);
        mThread.resetHardIn(FADE_OUT_LENGTH);
    }

    public boolean continuedChannel(){
        return continuedLastChannel;
    }

    public MonadJamSourceInfo getSourceInfo(){
        return mSourceInfo;
    }

    public void setSourceInfo(MonadJamSourceInfo info){
        mSourceInfo = info;

    }

    public void cancelCurrentChannel() {
        if (currentChannelIsLive){
            addXY(0, -1);
        }
        else if (!currentChannel.free){
            addXY(0, -1);
            undo();
        }
    }

    private void lockTheScreen(){
        if (lockScreen){

            Activity activity = (Activity) context;
            Display getO = activity.getWindowManager().getDefaultDisplay();
            if (getO.getWidth() > getO.getHeight()){
                activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
            }
            else {
                activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
            }
            isScreenLocked = true;
        }
    }
}
