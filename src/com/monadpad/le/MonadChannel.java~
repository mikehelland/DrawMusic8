package com.monadpad.common;

import com.monadpad.common.dsp.*;

import java.util.ArrayList;
import java.util.List;

public class MonadChannel {

    private boolean looping = false;

    private long finishInitiatedTime = 0;
    private long finishLength = 0;
    private float fadeLevel = 0;

    private boolean addedTime = false;

    private float[] scale;
    private int octaves;
    private float base;

    private boolean envActive = false;
    private final WtOsc ugOscA1 = new WtOsc();
    private final ExpEnv ugEnvA = new ExpEnv();
    public final Dac ugDac = new Dac();

    private final Delay ugDelay = new Delay(UGen.SAMPLE_RATE / 2);
    private final Flange ugFlange = new Flange(UGen.SAMPLE_RATE / 64, 0.25f);

    private final ArrayList<Float> panHistory = new ArrayList<Float>();
    private final ArrayList<Float> xpHistory = new ArrayList<Float>();
    private final ArrayList<Float> ypHistory = new ArrayList<Float>();
    private final ArrayList<Long> tHistory = new ArrayList<Long>();
    private final List<Float> fHistory =  new ArrayList<Float>();
    private int currentI = 0;

    private int instrument;
    private boolean virgin = true;

    boolean free = true;

    private boolean hasPans = false;

    MonadChannelViewInfo mInfo;

    private float gain;

    MonadChannelViewInfo getViewInfo(){
        return mInfo;
    }

    public MonadChannel(int pinstrument, String pScale, int pOctave, int pBase){

        mInfo = new MonadChannelViewInfo(pinstrument);

        boolean delay, flange, softTimbre, softEnvelope, softe, softt;
        boolean saw = false;
        instrument = pinstrument;
        if (pinstrument == 0)
        {
            delay = true; flange = false; softt = true; softe = true;
        }
        else if (pinstrument == 1)
        {
            delay = false; flange = false; softt = true; softe = false;
        }
        else if (pinstrument == 2)
        {
            delay = true; flange = false; softt = false; softe = true;
        }
        else if (pinstrument == 3)
        {
            delay = true; flange = false; softt = false; softe = false;
        }
        else if (pinstrument == 4)
        {
            delay = false; flange = true; softt = false; softe = true;
        }
        else if (pinstrument == 5)
        {
            delay = false; flange = false; softt = false; softe = false;
        }
        else if (pinstrument == 6)
        {
            delay = false; flange = false; softt = false; softe = true;
        }
        else if (pinstrument == 7)
        {
            delay = false; flange = false; softt = false; softe = true;
            saw = true;
        }
        else if (pinstrument == 8)
        {
            delay = false; flange = false; softt = false; softe = false;
            saw = true;
        }
        else if (pinstrument == 9)
        {
            delay = true; flange = false; softt = false; softe = true;
            saw = true;
        }
        else if (pinstrument == 10)
        {
            delay = true; flange = false; softt = false; softe = false;
            saw = true;
        }
        else
        {
            delay = false; flange = false; softt = true; softe = true;
        }
        softEnvelope = softe;
        softTimbre = softt;

        scale = buildScale(pScale);
        octaves = pOctave;
        base = (float) pBase;

        if (saw)
            ugOscA1.fillWithSaw();
        else if (softTimbre) {
            ugOscA1.fillWithHardSin(7.0f);
        } else {
            ugOscA1.fillWithSqrDuty(0.6f);
        }

        if (delay) {

            ugEnvA.chuck(ugDelay);

            if (flange) {
                ugDelay.chuck(ugFlange).chuck(ugDac);
            } else {
                ugDelay.chuck(ugDac);
            }
        } else {
            if (flange) {
                ugEnvA.chuck(ugFlange);
                ugFlange.chuck(ugDac);
            } else {
                ugEnvA.chuck(ugDac);
            }
        }


        ugOscA1.chuck(ugEnvA);
        if (!softEnvelope) {
            ugEnvA.setFactor(ExpEnv.hardFactor);
        }

        ugEnvA.setActive(true);
        envActive = true;

        setGain(0.75f);
    }

    public void setFreq(float freq){
        ugOscA1.setFreq(freq);
    }

    public void update(long nowInLoop){
        // ugDac.open();

        if (looping){
            if (virgin){
                //find out where we are in the loop and set the right I
                if (tHistory.get(tHistory.size() - 1) < nowInLoop)
                    currentI = tHistory.size();
                else {
                    for (int ii=0; ii<tHistory.size(); ii++){
                        if (tHistory.get(ii) >= nowInLoop){
                            currentI = ii;
                            break;
                        }
                    }
                }
                virgin =false;

            }
            if (tHistory.size() > currentI){
                try{
                    float freq = fHistory.get(currentI);
                    if (freq == -1){
                        mute();
                        currentI++;
                    }
                    else {
                        if (tHistory.get(currentI) <= nowInLoop){
                            if (!envActive){
                                unmute();
                            }
                            ugOscA1.setFreq(freq);
                            if (hasPans)
                                ugDac.pan(panHistory.get(currentI));
                            currentI++;
                        }

                    }
                }
                catch (IndexOutOfBoundsException e){ //e.printStackTrace();
                }
            }
            else{
                mute();
            }
        }

        if (finishLength > 0){
            float newfl = (float)(System.currentTimeMillis() - finishInitiatedTime) / (float)finishLength;
            if (newfl <= 1.0f && newfl != fadeLevel){
                fadeLevel = newfl;
                ugDac.fade(fadeLevel);
            }
        }

        ugDac.tick();

    }



    public void addXY(long time, float pan, float x, float y){

        float freq;
        if (y == -1){
            looping = false;
            freq = -1;
        }
        else{

            //set the freq
            freq = buildFrequency(scale, octaves, y, base);
            setFreq(freq);
            if (pan != -2f){
                ugDac.pan(pan);

            }
        }

        if (x > -1){
            if (time > -1){
                tHistory.add(time);
                addedTime = true;
            }
            if (pan != -2f){
                panHistory.add(pan);
                hasPans = true;
            }
            xpHistory.add(x);
            ypHistory.add(y);
            fHistory.add(freq);
        }

    }

    public float getHigh(){
        float high = 0;
        if (xpHistory.size() > 0){
            high = xpHistory.get(0);
            float newNumber;
            for (Float aXpHistory : xpHistory) {
                newNumber = aXpHistory;
                if (newNumber > high) high = newNumber;
            }
        }
        return high;
    }

    public float getLow(){
        float low = 0;
        if (xpHistory.size() > 0){
            low = xpHistory.get(0);
            float newNumber;
            for (Float aXpHistory : xpHistory) {
                newNumber = aXpHistory;
                if (newNumber < low) low = newNumber;
            }
        }
        return low;
    }


    public void prepareLoop(long loopDuration, float lineStart, float lineLength){
        if (!addedTime){
            tHistory.clear();
            for (Float aXpHistory : xpHistory) {

                tHistory.add((long) (((aXpHistory - lineStart) / lineLength) * (float) loopDuration));
            }
        }
        mute();
        looping = true;

    }

    public void popCherry(){
        virgin = false;
    }
    public void reset(){

        if(looping){
            mute();
        }
        currentI = 0;
    }

    public void slowFinish(){
        finish(2500);
    }
    public void finish(){
        finish(500);
    }

    public void finish(int ftime){
        looping = false;
        mute();
        finishInitiatedTime = System.currentTimeMillis();
        finishLength = ftime;
    }

    public void fade(int length){
        finishInitiatedTime = System.currentTimeMillis();
        finishLength = length;
    }

    public long getFinishTime(){
        return finishInitiatedTime + finishLength;
    }

    public void mute(){
        ugEnvA.setActive(false);
        envActive = false;
    }
    public void unmute(){
        ugEnvA.setActive(true);
        envActive = true;
    }
    public void unloop(){
        unmute();
        looping = false;
    }

    static float[] buildScale(String quantizerString) {
        if (quantizerString != null && quantizerString.length() > 0) {
            String[] parts = quantizerString.split(",");
            float[] scale = new float[parts.length];
            for (int i = 0; i < parts.length; i++) {
                scale[i] = Float.parseFloat(parts[i]);
            }
            return scale;
        } else {
            return null;
        }
    }

    static float buildFrequency(final float[] scale, final int octaves, float input, float base) {
        input = Math.min(Math.max(input, 0.0f), 1.0f);
        //final float base = 24;        //final float base = 48;

        float mapped;
        if (scale == null) {
            mapped = base + input * octaves * 12.0f;
        } else {
            int idx = (int) ((scale.length * octaves + 1) * input);
            mapped = base + scale[idx % scale.length] + 12 * (idx / scale.length);
        }
        return (float) Math.pow(2, (mapped - 69.0f) / 12.0f) * 440.0f;

    }

    public String getChannelInfo(){
        StringBuilder info = new StringBuilder();
        info.append(instrument);
        for (int ix = 0; ix<xpHistory.size(); ix++){
            info.append(";");
            info.append(xpHistory.get(ix));
            info.append(";");
            info.append(ypHistory.get(ix));
        }
        return info.toString();
    }

    public void close(){
        ugDac.close();
    }


    public void bend(float amt, float amtP){
        mInfo.path.offset(0, -1 * amt);
        for (int ii = 0; ii < ypHistory.size(); ii++){
            if (fHistory.get(ii) != -1){
                ypHistory.set(ii, ypHistory.get(ii) + amtP);
                fHistory.set(ii, buildFrequency(scale, octaves, ypHistory.get(ii), base));
            }
        }

    }

    public boolean hitTest(float x, float y){
        return Math.abs(mInfo.originX - x) < 35 && Math.abs(mInfo.originY - y) < 35;
    }

    public float[] getXYs(){
        float[] ret = new float[xpHistory.size() * 2];
        int i = 0;
        int j = 0;
        for (float x : xpHistory){
            ret[i] = x;
            ret[i + 1] = ypHistory.get(j);
            j = j +1;
            i = i + 2;
        }
        return ret;
    }

    void rebuildFrequencies(String scale, int octaves, int base){
        this.scale = buildScale(scale);
        this.octaves = octaves;
        this.base = (float) base;

        fHistory.clear();
        float freq;
        for (Float y : ypHistory){
            if (y == -1){
                freq = -1;
            }
            else {
                freq = buildFrequency(this.scale, this.octaves, y, this.base);
            }
            fHistory.add(freq);
        }
    }

    public void pan(float v) {
        ugDac.pan(v);
    }

    public float getPan() {
        return ugDac.getLastPan();
    }

    public void setGain(float v) {
        gain = v;
        ugEnvA.setGain(2*v*v);
    }

    public float getGain(){
        return gain;
    }
}
